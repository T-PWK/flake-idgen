{"name":"Flake-idgen","tagline":"Flake ID generator yields k-ordered, conflict-free ids in a distributed environment","body":"Flake ID Generator \r\n===========\r\n[![Build Status](https://travis-ci.org/T-PWK/flake-idgen.png?branch=master)](https://travis-ci.org/T-PWK/flake-idgen) [![NPM version](https://badge.fury.io/js/flake-idgen.png)](http://badge.fury.io/js/flake-idgen)\r\n\r\nFlake ID generator yields k-ordered, conflict-free ids in a distributed environment.\r\n\r\n## Flake Numbers ##\r\n\r\nThe Flake ID is made up of: `timestamp`, `datacenter`, `worker` and `counter`. Examples in the following table: \r\n```\r\n+-------------+------------+--------+---------+--------------------+\r\n|  Timestamp  | Datacenter | Worker | Counter | Flake ID           |\r\n+-------------+------------+--------+---------+--------------------+\r\n| 0x8c20543b0 |   00000b   | 00000b |  0x000  | 0x02308150ec000000 |\r\n+-------------+------------+--------+---------+--------------------+\r\n| 0x8c20543b1 |   00000b   | 00000b |  0x000  | 0x02308150ec400000 |\r\n+-------------+------------+--------+---------+--------------------+\r\n| 0x8c20543b1 |   00000b   | 00000b |  0x001  | 0x02308150ec400001 |\r\n+-------------+------------+--------+---------+--------------------+\r\n| 0x8c20543b1 |   00000b   | 00000b |  0x002  | 0x02308150ec400002 |\r\n+-------------+------------+--------+---------+--------------------+\r\n| 0x8c20543b1 |   00000b   | 00000b |  0x003  | 0x02308150ec400003 |\r\n+-------------+------------+--------+---------+--------------------+\r\n| 0x8c20c0335 |   00011b   | 00001b |  0x000  | 0x02308300cd461000 |\r\n+-------------+------------+--------+---------+--------------------+\r\n| 0x8c20c0335 |   00011b   | 00001b |  0x001  | 0x02308300cd461001 |\r\n+-------------+------------+--------+---------+--------------------+\r\n```\r\n\r\nAs you can see, each Flake ID is 64 bits long, consisting of:\r\n* `timestamp`, a 42 bit long number of milliseconds elapsed since 1 January 1970 00:00:00 UTC \r\n* `datacenter`, a 5 bit long datacenter identifier. It can take up to 32 unique values (including 0)\r\n* `worker`, a 5 bit long worker indentifier. It can take up to 32 unique values (including 0)\r\n* `counter`, a 12 bit long counter of ids in the same millisecond. It can take up to 4096 unique values. \r\n\r\nBreakdown of bits for an id e.g. `5828128208445124608` (counter is `0`, datacenter is `7` and worker `3`) is as follows:\r\n```\r\n 010100001110000110101011101110100001000111 00111 00011 000000000000\r\n                                                       |------------| 12 bit counter\r\n                                                 |-----|               5 bit worker\r\n                                           |-----|                     5 bit datacenter\r\n                                           |----- -----|              10 bit generator identifier\r\n|------------------------------------------|                          42 bit timestamp\r\n```\r\n\r\nNote that composition of `datacenter id` and `worker id` makes 1024 unique generator identifiers. By modifying datacenter and worker id we can get up to 1024 id generators on a single machine (e.g. each running in a separate process) or have 1024 machines with a single id generator on each. It is also possible to provide a single 10 bit long identifier (up to 1024 values). That id is internally split into `datacenter` (the most significant 5 bits) and `worker` (the least significant 5 bits).\r\n\r\n## Usage ##\r\n\r\nFlake ID Generator returns 8 byte long node [Buffer](http://nodejs.org/api/buffer.html) objects with its bytes representing 64 bit long id. Note that the number is stored in Big Endian format i.e. the most significant byte of the number is stored in the smallest address given and the least significant byte is stored in the largest.\r\n\r\nFlake id generator instace has one method `next(cb)` returning generated id (if a callback function is not provided) or calling provided callback function with two arguments: `error` and `generated id`.\r\n\r\nThe following example uses `next` with no callback function:\r\n\r\n```js\r\nvar FlakeId = require('flake-idgen');\r\nvar flakeIdGen = new FlakeId();\r\n\r\nconsole.log(flakeIdGen.next());\r\nconsole.log(flakeIdGen.next());\r\nconsole.log(flakeIdGen.next());\r\n```\r\n\r\nIt would give something like:\r\n```\r\n<Buffer 50 dd d5 99 01 c0 00 00>\r\n<Buffer 50 dd d5 99 02 80 00 00>\r\n<Buffer 50 dd d5 99 02 80 00 01>\r\n```\r\n\r\nThe following example uses `next` with callback function:\r\n```js\r\nvar FlakeId = require('flake-idgen');\r\nvar flakeIdGen = new FlakeId();\r\n\r\nflakeIdGen.next(function (err, id) {\r\n     console.info(id);\r\n})\r\n\r\nflakeIdGen.next(function (err, id) {\r\n     console.info(id);\r\n})\r\n```\r\n\r\nIt would give something like:\r\n```\r\n<Buffer 50 dd d6 49 ef c0 00 00>\r\n<Buffer 50 dd d6 49 f0 00 00 00>\r\n```\r\n\r\nFlake Id generator constructor takes optional parameter (generator configuration options) with the following properties:\r\n* `datacenter` (5 bit) - datacenter identifier. It can have values from 0 to 31.\r\n* `worker` (5 bit) - worker identifier. It can have values from 0 to 31.\r\n* `id` (10 bit) - gnerator identifier. It can have values from 0 to 1023. It can be provided instead of `datacenter` and `worker` identifiers.\r\n* `epoch` - number used to reduce value of a generated timestamp. Note that this number should not exceed number of milliseconds elapsed since 1 January 1970 00:00:00 UTC. It can be used to generate _smaller_ ids.\r\n\r\nExample of using `datacenter` and `worker` identifiers:\r\n```js\r\nvar FlakeId = require('flake-idgen')\r\n\r\nvar flakeIdGen1 = new FlakeId();\r\nvar flakeIdGen2 = new FlakeId({ datacenter: 9, worker: 7 });\r\n\r\nconsole.info(flakeIdGen1.next());\r\nconsole.info(flakeIdGen2.next());\r\n```\r\n\r\nIt would give something like:\r\n```\r\n<Buffer 50 dd da 8f 43 40 00 00>\r\n<Buffer 50 dd da 8f 43 d2 70 00>\r\n```\r\n\r\nExample of using `epoch` parameter:\r\n```js\r\nvar FlakeId = require('flake-idgen')\r\n\r\nvar flakeIdGen1 = new FlakeId();\r\nvar flakeIdGen2 = new FlakeId({ epoch: 1300000000000 });\r\n\r\nconsole.info(flakeIdGen1.next());\r\nconsole.info(flakeIdGen2.next());\r\n```\r\n\r\nIt would give something like:\r\n```\r\n<Buffer 50 dd db 00 d1 c0 00 00>\r\n<Buffer 05 32 58 8e d2 40 00 00>\r\n```\r\n\r\n### Formatting ###\r\n\r\nFlake Id generator returns node Buffer representing 64-bit number for the sake of future extensions or returned buffer modifications. Node Buffer can also be very easily converted to string format. There is a NPM [biguint-format](https://npmjs.org/package/biguint-format) module which provides Buffer to string conversion functionality e.g.\r\n\r\n```js\r\nvar intformat = require('biguint-format')\r\n    , FlakeId = require('flake-idgen')\r\n\r\nvar flakeIdGen1 = new FlakeId();\r\nvar flakeIdGen2 = new FlakeId({ epoch: 1300000000000 });\r\n\r\nconsole.info(intformat(flakeIdGen1.next(), 'dec'));\r\nconsole.info(intformat(flakeIdGen1.next(), 'hex', { prefix: '0x' }));\r\n\r\nconsole.info(intformat(flakeIdGen2.next(), 'dec'));\r\nconsole.info(intformat(flakeIdGen2.next(), 'hex', { prefix: '0x' }));\r\n```\r\n\r\nIt would give something like:\r\n```js\r\n5827056208820830208 // flakeIdGen1 decimal format\r\n0x50dddcbfb5c00001  // flakeIdGen1 hex format\r\n\r\n374461008833413120 // flakeIdGen2 decimal format\r\n0x5325a4db6000002  // flakeIdGen2 hex format\r\n```\r\n\r\nGenerated id could also be converted to binary string format, split into 4 digit groups of 0's and 1's e.g.\r\n```js\r\nvar foramt = require('biguint-format')\r\n    , idGen = new (require('flake-idgen'))\r\n\r\nfor (var i = 0; i < 5; i++) {\r\n\tconsole.info(format(idGen.next(), 'bin', { groupsize: 4 }));\r\n};\r\n```\r\n\r\nIt would give something like:\r\n```js\r\n0101 0000 1101 1111 1011 0110 0001 0101 1100 0001 0100 0000 0000 0000 0000 0000 // 0x50 df b6 15 c1 40 00 00\r\n0101 0000 1101 1111 1011 0110 0001 0101 1100 0101 0000 0000 0000 0000 0000 0000 // 0x50 df b6 15 c5 00 00 00\r\n0101 0000 1101 1111 1011 0110 0001 0101 1100 0101 0000 0000 0000 0000 0000 0001 // 0x50 df b6 15 c5 00 00 01\r\n0101 0000 1101 1111 1011 0110 0001 0101 1100 0101 0100 0000 0000 0000 0000 0000 // 0x50 df b6 15 c5 40 00 00\r\n0101 0000 1101 1111 1011 0110 0001 0101 1100 0101 0100 0000 0000 0000 0000 0001 // 0x50 df b6 15 c5 40 00 01\r\n```\r\n\r\n## Author ##\r\nWriten by Tom Pawlak - [Blog](http://blog.tompawlak.org)\r\n\r\n## License ##\r\n\r\nCopyright (c) 2014 Tom Pawlak\r\n\r\nMIT License : http://blog.tompawlak.org/mit-license\r\n","google":"UA-52086748-1","note":"Don't delete this file! It's used internally to help with page regeneration."}